''' 백트래킹의 기본.
문제
자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.

1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열

입력
첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)

출력
한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 
중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.

수열은 사전 순으로 증가하는 순서로 출력해야 한다.
'''
''' 
[DFS 전략]
1. visted 탐색했는 지의 여부
2. out 탐색 내용
3. 재귀 함수 시
    1) 탈출조건 : Depth == M
    2) 탐사를 안했을 경우 진행하는 것
        - Depth 탐색 전: 탐사 시작(중복 제거), 탐사 내용 append
        - Depth 탐색 후: 다음 탐사 준비, 탐사 내용 pop
'''


import sys
N, M = map(int, sys.stdin.readline().split())

# visted[] <- 한 층에서 탐색하는 노드의 층 개수만큼의 요소가 있고, 
# 각 요소는 탐색했는지의 여부 boolean이다.
output = []
visited = [False] * N # 처음에는 아무것도 탐색하지 않은 상태.
def DFS(depth, N, M):
    if depth == M: # 재귀 종료의 조건
        print(' '.join(map(str,output))) # 출력
         # 만들어진 내용을 print하고 재귀를 종료한다.
    
    for i in range(N): # visited
        if not visited[i]: # visited[0]은 첫번째로 탐색한 노드를 탐색했는지의 여부! <- 이게 있으니깐 1 이 있으면 2 를 안넣는 것.
            visited[i] = True # 해당 노드의 탐색여부. True
            output.append(i+1) # i가 0부터니깐 i+1가 1부터. <- 실제 탐색.
            DFS(depth+1, N, M) # 재귀
            # 재귀 끝났을 때 마지막으로 실행되는 것.
            visited[i] = False # 다음 탐색을 위해서 False로 바꿔 둔다.
            output.pop() # 다음 탐색을 위해서 reset해준다.

DFS(0, N, M)


'''
DFS 는 깊이 우선 탐색.
아주 비효율적.
가능한 모든 경로를 탐색한다.
경우의 수가 고정적이지만 경우의 수가 아주 많아질 수 있다.

DFS의 효율성을 개선한 것이 Backtracking
백트래킹은 가던 길이 잘못된 길인 것 같으면 되돌아오는 것을 말한다.
잘못된 길인 것을 인지하려면, 잘못된 길에 대한 조건이 필요하다.
그래서 Backtracking은 특정한 조건을 만족하는 경우를 탐색하는 경우에 사용한다.
Backtraking은 다른말로 가지치기라고도 한다.
서치하다가 답이 안될 것 같다는 판단이 들면, 해당 서치를 종료하고 
부모 노드로 돌아가서 다음 자식 노드의 길로 들어선다.
최악의 경우 복잡도가 DFS와 같지만, 최악의 경우만 아니라면 복잡도가 줄어든다.

<Backtracking 용어>
Backtracking: "돌아가기", 유망하지 않다고 결정되면 그 노드의 이전 부모 노드로 돌아가는 것.
Promising: "유망한", 해가 될 가능성이 있으면 유망하다고 한다. 
Pruning: "가지치기", 유망하지 않은 노드에 가지 않는 것. 손절

<Backtracking 구현법>
1. DFS를 일단 구현한다.
2. DFS에서 유망하지 않은 자식 노드를 찾는 함수를 구현.
3. DFS의 각 iteration에서 유망하지 않은 자식 노드를 발견하면 가지치기.
'''
    


